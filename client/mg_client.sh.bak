#!/bin/bash

# 监控指标收集及告警v1.0

# 设置英文环境，以免脚本计算出错
export LANG=en_US.UTF-8

cd `dirname $0`

# 判断有没有加-y参数,加了-y参数运行才会发送告警
yes_flag=0

while getopts ":y" opt; do
    case $opt in
        y)
            yes_flag=1
            ;;
    esac
done

# 报警日志，用于避免24小时内的重复报警
ALERT_LOG="./logs/alert_log.txt"
source ./mg_client.rc
# 网卡名称（目前是自动找第一个物理网卡，也可以指定）
interface=$(ls /sys/class/net -l | grep pci | awk '{print $9}' | head -n 1)
localIP=$(ip a show dev $interface | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 )


echo "本机名称:$CMI_HOST"
echo "服务端口:$CMI_PORTS"
echo "短信接口:$CMI_SERVER_ENDPOINT"


function cpu_usage {
	local operator=$1
	local threshold=$2

	# 第一次读取
	read cpu user nice system idle iowait irq softirq steal guest guest_nice < <(grep '^cpu ' /proc/stat)
	total1=$((user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice))
	user1=$user
	nice1=$nice
	system1=$system
	idle1=$idle
	iowait1=$iowait
	irq1=$irq
	softirq1=$softirq

	sleep 1

	# 第二次读取
	read cpu user nice system idle iowait irq softirq steal guest guest_nice < <(grep '^cpu ' /proc/stat)
	total2=$((user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice))
	user2=$user
	nice2=$nice
	system2=$system
	idle2=$idle
	iowait2=$iowait
	irq2=$irq
	softirq2=$softirq

	# 计算差值
	total=$((total2 - total1))
	user=$((user2 - user1))
	nice=$((nice2 - nice1))
	system=$((system2 - system1))
	idle=$((idle2 - idle1))
	iowait=$((iowait2 - iowait1))
	irq=$((irq2 - irq1))
	softirq=$((softirq2 - softirq1))

	# 计算各项占比
	cpu_percent=$((100 * ( total - idle ) / total))
	idle_percent=$((100 * idle / total))
	user_percent=$((100 * user / total))
	system_percent=$((100 * system / total))
	nice_percent=$((100 * nice / total))
	iowait_percent=$((100 * iowait / total))
	irq_percent=$((100 * irq / total))
	softirq_percent=$((100 * softirq / total))
	other_percent=$((100 * ( total - ( user + nice + system + idle + iowait + irq + softirq)) / total))

	# 输出结果
	local str="CPU使用率(%):${cpu_percent}"
	local metricName="cpu_usage"
	# echo "CPU 使用率(%): $cpu_percent"
	# echo "CPU 空闲时间占比: $idle_percent%"
	# echo "用户空间 CPU 使用率: $user_percent%"
	# echo "内核空间 CPU 使用率: $system_percent%"
	# echo "Nice 进程 CPU 使用率: $nice_percent%"
	# echo "iowait 状态占比: $iowait_percent%"
	# echo "CPU 中断时间占比: $irq_percent%"
	# echo "CPU 软中断时间占比: $softirq_percent%"
	# echo "其他 CPU 使用率: $other_percent%"

	if [[ $(echo "$cpu_percent $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function cpu_load_avg1 {
	local operator=$1
	local threshold=$2
	read cpu_load < <(echo "scale=2;`awk '{print $1}' /proc/loadavg` / `nproc`" | bc | awk '{printf "%.2f\n", $0}' )
	local str="CPU1分钟核心平均负载(1):$cpu_load "
	local metricName="cpu_load_avg1"

	if [[ $(echo "$cpu_load $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str

}

function mem_usage {
	local operator=$1
	local threshold=$2
	local MemAvailable=`cat /proc/meminfo | grep MemAvailable | awk '{print $2}'`;
	local MemTotal=`cat /proc/meminfo | grep MemTotal | awk '{print $2}'`;
	local mem_u=$((100 * (MemTotal - MemAvailable) / MemTotal));
	local str="内存使用率(%):$mem_u"
	local metricName="mem_usage"

	if [[ $(echo "$mem_u $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function total_open_files {
	
	local operator=$1
	local threshold=$2
	local open_files=`lsof -u $USER | wc -l`

	local str="打开的文件数(个): $open_files"
	local metricName="total_open_files"

	if [[ $(echo "$open_files $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function disk_used {
	local operator=$1
	local threshold=$2
	local disk_use=`df -k /home | tail -n 1 | awk '{print $5}' | sed 's/%$//' `
	local str="/home挂载点使用率(%): $disk_use"
	local metricName="disk_used"

	if [[ $(echo "$disk_use $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function disk_fs_rwstat {
	local operator=$1
	local threshold=$2
	local fs=`df /home | tail -n 1 | awk '{print $1}'`
	local stat=$(grep $fs /proc/mounts | awk '{print $4}' | cut -f 1 -d ,)
	local str="/home读写状态: $stat"
	local metricName="disk_fs_rwstat"

	if [ "$stat" $operator "$threshold" ]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function disk_inode_usage {
	local operator=$1
	local threshold=$2
	local inode_use=`df -i /home | tail -n 1 | awk '{print $5}' | sed 's/%$//' `
	local str="/home INode使用率(%): $inode_use"
	local metricName="disk_inode_usage"

	if [[ $(echo "$inode_use $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function disk_io {
	local operator=$1
	local threshold=$2
	fs=`df /home | tail -n 1 | awk '{print $1}'`
	fs_real_withpath=$(ls -l $fs | awk '{print $11}')
	fs_real=$(basename $fs_real_withpath)
	
	#第一次读取
	read major minor name rio rmerge rsect ruse wio wmerge wsect wuse running use aveq < <(grep $fs_real /proc/diskstats | head -n 1)
	prev_rio=$rio
	prev_ruse=$ruse
	prev_wio=$wio
	prev_wuse=$wuse

	read major minor name rio rmerge rsect ruse wio wmerge wsect wuse running use aveq < <(grep $fs_real /proc/diskstats | head -n 1)
	rio_diff=$((rio - prev_rio))
    ruse_diff=$((ruse - prev_ruse))
    wio_diff=$((wio - prev_wio))
    wuse_diff=$((wuse - prev_wuse))

	# 计算平均耗时
    if [ $rio_diff -gt 0 ]; then
        avg_ruse=$((ruse_diff / rio_diff))
    else
        avg_ruse=0
    fi

    if [ $wio_diff -gt 0 ]; then
        avg_wuse=$((wuse_diff / wio_diff))
    else
        avg_wuse=0
    fi

	local str1="读操作平均耗时(ms): $avg_ruse"
	local str2="写操作平均耗时(ms): $avg_wuse"
	local metricName1="disk_io_r"
	local metricName2="disk_io_w"

	if [[ $(echo "$avg_ruse $operator $threshold" | bc) -eq 1 ]]; then
		str1="${str1}(${operator}${threshold}超出阈值)"
		send_alert $metricName1 "告警" "$str1" 
	else
		send_alert $metricName1 "恢复" "$str1" 
	fi
	echo $str1

	if [[ $(echo "$avg_wuse $operator $threshold" | bc) -eq 1 ]]; then
		str2="${str2}(${operator}${threshold}超出阈值)"
		send_alert $metricName2 "告警" "$str2"
	else
		send_alert $metricName2 "恢复" "$str2"
	fi
	echo $str2
}

function net_drop_rate {
	local operator=$1
	local threshold=$2

	# 网卡名称（目前是自动找第一个物理网卡，也可以指定）
	# interface="enp0s3"
	# interface=$(ls /sys/class/net -l | grep pci | awk '{print $9}' | head -n 1)

	# 第一次读取 /proc/net/dev
	read prev_rx_packets prev_rx_drops prev_tx_packets prev_tx_drops < <(awk -v iface="$interface" '$0 ~ iface ":" {print $3, $5, $11, $13}' /proc/net/dev)

	# 等待一秒
	sleep 1

	# 第二次读取 /proc/net/dev
	read curr_rx_packets curr_rx_drops curr_tx_packets curr_tx_drops < <(awk -v iface="$interface" '$0 ~ iface ":" {print $3, $5, $11, $13}' /proc/net/dev)

	# 计算差值
	rx_packets_diff=$((curr_rx_packets - prev_rx_packets))
	rx_drops_diff=$((curr_rx_drops - prev_rx_drops))
	tx_packets_diff=$((curr_tx_packets - prev_tx_packets))
	tx_drops_diff=$((curr_tx_drops - prev_tx_drops))

	# 计算丢包率
	if [ $rx_packets_diff -gt 0 ]; then
		rx_drop_rate=$(echo "scale=4; $rx_drops_diff / $rx_packets_diff * 100" | bc)
	else
		rx_drop_rate=0
	fi
	if [ $tx_packets_diff -gt 0 ]; then
		tx_drop_rate=$(echo "scale=4; $tx_drops_diff / $tx_packets_diff * 100" | bc)
	else
		tx_drop_rate=0
	fi

	# 输出结果
	# echo "Interface: $interface"
	# echo "Received packets (last second): $rx_packets_diff"
	# echo "Transmited packets (last second): $tx_packets_diff"
	# echo "RX Dropped packets (last second): $rx_drops_diff"
	# echo "TX Dropped packets (last second): $tx_drops_diff"
	local str1="接收丢包率(%): $rx_drop_rate"
	local str2="发送丢包率(%): $tx_drop_rate"
	local metricName1="rx_drop_rate"
	local metricName2="tx_drop_rate"

	if [[ $(echo "$rx_drop_rate $operator $threshold" | bc) -eq 1 ]]; then
		str1="${str1}(${operator}${threshold}超出阈值)"
		send_alert $metricName1 "告警" "$str1" 
	else
		send_alert $metricName1 "恢复" "$str1"
	fi
	echo $str1

	if [[ $(echo "$tx_drop_rate $operator $threshold" | bc) -eq 1 ]]; then
		str2="${str2}(${operator}${threshold}超出阈值)"
		send_alert $metricName2 "告警" "$str2" 
	else
		send_alert $metricName2 "恢复" "$str2"
	fi
	echo $str2
}

function net_tcp_time_wait {
	local operator=$1
	local threshold=$2
	local count=$(ss -s | grep -oP 'timewait \K\d+')
	local str="time-wait状态连接数(个): $count"
	local metricName="net_tcp_time_wait"

	if [[ $(echo "$count $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function net_tcp_close_wait {
	local operator=$1
	local threshold=$2
	local count=$(ss -t state close-wait | grep -c 'CLOSE-WAIT')
	local str="close-wait状态连接数(个): $count"
	local metricName="net_tcp_close_wait"

	if [[ $(echo "$count $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function net_tcp_retrans_rate {
	local operator=$1
	local threshold=$2

	# 第一次采样
	local retrans1=$(awk '/Tcp:/ {print $13}' /proc/net/snmp | tail -n 1)
	local seg_out1=$(awk '/Tcp:/ {print $12}' /proc/net/snmp | tail -n 1)

	# 等待 3 秒
	sleep 3

	# 第二次采样
	local retrans2=$(awk '/Tcp:/ {print $13}' /proc/net/snmp | tail -n 1)
	local seg_out2=$(awk '/Tcp:/ {print $12}' /proc/net/snmp | tail -n 1)

	# 计算差值
	local retrans=$((retrans2 - retrans1))
	local seg_out=$((seg_out2 - seg_out1))

	# 计算重传率
	if [ "$seg_out" -gt 0 ]; then
		retrans_rate=$(echo "scale=4; $retrans / $seg_out * 100" | bc)
	else
		retrans_rate=0
	fi

	# 输出结果
	local str="TCP重传率(%): $retrans_rate"
	local metricName="net_tcp_retrans_rate"

	if [[ $(echo "$retrans_rate $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function time_offset {
	local operator=$1
	local threshold=$2
	local offset=$(chronyc tracking | grep "System" | awk '{print $4}')
	local str="时间偏移量(秒): $offset"
	local metricName="time_offset"

	if [[ $(echo "$offset $operator $threshold" | bc) -eq 1 ]]; then
		str="${str}(${operator}${threshold}超出阈值)"
		send_alert $metricName "告警" "$str" 
	else
		send_alert $metricName "恢复" "$str" 
	fi
	echo $str
}

function check_port {
	local ports=($CMI_PORTS)
	echo "检测端口:$CMI_PORTS"
	for port in "${ports[@]}";do 
		local str="端口:$port"
		local metricName="port_$port"
		if nc -z $localIP $port ; then
			str="${str}(正常)"
			send_alert $metricName "恢复" "$str" 
		else 
			str="${str}(异常)"
			send_alert $metricName "告警" "$str" 
		fi
		echo $str
	done
}

# 发送报警的函数-
function send_alert {

	local metric=$1
	local AlertType=$2
    local message=$3
    local current_time=$(date +"%Y%m%d%H%M%S")  # 当前时间
    local last_alert_time
	local last_alert_type

	# 读取上次指标报警或恢复的时间
    if [[ -f "$ALERT_LOG" ]]; then
		if [ $(grep $metric $ALERT_LOG | tail -n 1 | wc -l) -eq "1" ];then
        	last_alert_time=$(grep $metric $ALERT_LOG | tail -n 1 | cut -f1 -d#)
        	last_alert_type=$(grep $metric $ALERT_LOG | tail -n 1 | cut -f3 -d#)
			# echo "存在指标记录"
		else
			last_alert_time=0
			last_alert_type=""
			# echo "不存在指标记录"
		fi
    else
        last_alert_time=0
		last_alert_type=""
		# echo "不存在指标记录且不存在日志文件"
    fi

	local needSend="N"
	local time_diff=$((current_time - last_alert_time))
	if ((time_diff < 1000000)); then  # 24 小时
		# echo "记录时间小于24小时"
		if [[ "$AlertType" != "$last_alert_type" ]];then
			echo "alerttype不相同"
			needSend="Y"
		fi 
	else 
		# echo "记录时间大于24小时"
		if [[ "$AlertType" == "告警" ]];then
			# echo "alerttype为告警"
			needSend="Y"
		fi
	fi

	# echo "needSend is $needSend"
	if [[ $yes_flag -eq 1 ]]; then
		if [[ "$needSend" == "Y" ]];then
			local type=""
			if [[ "$AlertType" == "告警" ]];then
				type="1"
			fi
			if [[ "$AlertType" == "恢复" ]];then
				type="0"
			fi
			curl -X POST -H $'Content-Type: application/json' -d "{\"host\":\"$CMI_HOST\",\"type\":\"$type\",\"ip\":\"$localIP\",\"message\": \"$message\"}" $CMI_SERVER_ENDPOINT
			local result=$?
			local curlResult=""
			if [[ "$result" == "0" ]];then
				curlResult="发送成功"
			else
				curlResult="发送失败"
			fi
			# 更新报警日志
			# echo "$current_time#$metric#$AlertType#$message"
			echo "$current_time#$metric#$AlertType#$message#$curlResult" >> "$ALERT_LOG"
		fi
	fi
}

cpu_usage '>=' 80 &
cpu_load_avg1 '>=' 0.7 &
mem_usage '>=' 85 &
total_open_files '>=' 50000 &
disk_used '>=' 90 &
disk_fs_rwstat '!=' rw &
disk_inode_usage '>=' 80 &
disk_io '>=' 5 &
net_drop_rate '>=' 5 &
net_tcp_time_wait '>=' 500 &
net_tcp_close_wait '>=' 30 &
net_tcp_retrans_rate '>=' 20 &
time_offset '>=' 0.5 &
check_port &

wait
